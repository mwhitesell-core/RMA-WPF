/* cpi.c
 Purpose: provides socket connection to Web and interface to Cobol program
	  to provide CPI (central patient Index) lookup against RMA unix 
	  database
 Modifcation History:
 2002/apr/01 B.E. - original
TODO: 'send' uses 3040 hard coded - should use CONST

*/
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <netdb.h>
#include <errno.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <string.h>
#include <ctype.h>
#include <stdio.h>
#include <time.h>

#define MAX_PATIENT_RECORD_SIZE		343		/* TODO: to short? */
#define MAX_PATIENT_RECS_BUFFER_SIZE	3438 
#define MAX_SOCKET_BUFFER_SIZE		2056		/* TODO: to long? */

#define DEFAULT_PORT 12345	/* port for service */

extern int validate();          /* Cobol program - */
extern void cobexit();		/* close down Cobol system and exit */
extern int cobprintf();         /* COBOL display from C */
extern int cobgetch();          /* COBOL character get */

main( argc, argv )
	int argc;
	char *argv[];
{

  char socketBuffer[MAX_SOCKET_BUFFER_SIZE];
  int s, newSocket, retcode, addrlen;
  long bufferCount;
  struct sockaddr_in addr;
  struct servent *sp;
  int strlen();
  int strncmp();
  int keepRunning;
  int CobolStatus;
  long requestLength;
  char patientRecsBuffer[MAX_PATIENT_RECS_BUFFER_SIZE];
  int strlen();
  int pid;
  char *shutdownString="~RMAshutDOWNcommand!~";
  time_t currentDateTime;
  int debugON;
  int auditON;
  FILE *auditFile;
  FILE *debugFile;
  FILE *xFile;

  debugON = 1 ;/* debuging ON ONLY for testing */
  auditON = 1 ;	/* auditing should ALWAYS be on */

  if (auditON) auditFile = fopen("/dyad/web/audit.log", "a");
  if (debugON) debugFile = fopen("/dyad/web/debug.log", "a");

  s = socket( AF_INET, SOCK_STREAM, 0 );

  time(&currentDateTime);

  if(s ==-1 ){
        if (auditON)  {
	    fprintf(auditFile,"%s\n",ctime(&currentDateTime));
	    fprintf(auditFile, ": FATAL Error - Server can't create socket\n");
	}
	exit(1);
  }

  memset(&addr, 0, sizeof(addr));
  sp = getservbyname( "webstar", "tcp" );

  if( sp != NULL ) {
	addr.sin_port = sp->s_port;
  } else {
	addr.sin_port = htons(DEFAULT_PORT);
  }

  addr.sin_family = AF_INET;
  addr.sin_addr.s_addr = INADDR_ANY;

  if( bind( s, (struct sockaddr *) &addr, sizeof(addr) ) == -1){
	perror("bind");
	exit(1);
  }

  keepRunning = 1;
  do 
  {
        /*
        ** The listen call sets the number of pending connections
        ** and changes the socket state to LISTEN - indicating a
        ** willingness to accept new connections.
        */
	if( listen( s,3 )==-1 ){
  	   perror("listen");
	   exit(1);
	}

	addrlen = sizeof( addr );
	if (debugON) fprintf(debugFile, "BEFORE Accept\n");
	newSocket = accept( s, (struct sockaddr *) &addr, &addrlen );

	if (debugON) fprintf(debugFile, "AFTER  Accept:s/sock=%d/%d\n",s,newSocket);
	if ( newSocket == -1 ) {
	    perror("accept");
	    exit(1);
	}
	if (debugON) fprintf(debugFile, "AFTER Accept ERROR check\n");

	/* fork to create process to handle the request)*/

	pid = fork();

	if ( pid < 0 ) { 
            if (auditON)  {
		fprintf(auditFile,"%s\n",ctime(&currentDateTime));
	        fprintf(auditFile, ": FATAL Error - Can't fork\n");
	    }
	    exit(1);
	}

	/* if not running Child(ie. Parent) process after fork, then shutdown)*/

	if ( !pid == 0 ) {
	    if (debugON) fprintf(debugFile, "PARENT - breaking...\n");
	    break;
	} else {
	    if (debugON) fprintf(debugFile, "Running CHILD\n");
	}


        if (auditON || debugON)  {
	    fprintf(auditFile,"%s\n",ctime(&currentDateTime));
	    fprintf(auditFile, 
	    		": Connection accepted from IP address:%s port:%d\n",
	    		inet_ntoa(addr.sin_addr),addr.sin_port);
	}
        if (auditON || debugON)  {
	    fprintf(auditFile,"%s\n",ctime(&currentDateTime));
	    fprintf(auditFile, 
	    		": Connection accepted from IP address:%s port:%d\n",
	    		inet_ntoa(addr.sin_addr),addr.sin_port);
	}

        /*
        ** Server Main Loop - loop indefinitely processing the received data
        ** from the 'connected' client until client requests a 'disconnect'
        ** an error occurs, or the "RMA SHUTDOWN" signal is received
        */
	for(;;) {
	    retcode=recv( newSocket, &socketBuffer, MAX_SOCKET_BUFFER_SIZE, 0 );
	    if ( retcode < 0) {
                if (auditON)  {
		    fprintf(auditFile,"%s\n",ctime(&currentDateTime));
                    fprintf(auditFile, ": RECEIVE Error - Return Code= %s, Performing Shutdown\n",retcode);
		}
                close(newSocket);
                newSocket=NULL;
		perror("recv");
		perror("retcode");
		exit(1);
	    }
	    else if ( retcode ==0 )  {  /* EOF */
                if (debugON)  {
                    fprintf(debugFile, 
			"Return Code = 0 -- Client Requested DISCONNECT\n");
		}
                close(newSocket);
                newSocket=NULL;
		break;
	    }

	    if ( strlen(socketBuffer) > 0 ) {
xFile = fopen("/dyad/web/x.log", "a");
fprintf(xFile,"RECEIVED=%s\n", socketBuffer);
fclose(xFile);
                if (debugON)  {
                        fprintf(debugFile,"RECEIVED=%s\n", socketBuffer);
 		}
                if (!strncmp(shutdownString,socketBuffer,10)) {
                    if (auditON) {
			fprintf(auditFile,"%s\n",ctime(&currentDateTime));
 			fprintf(auditFile,": RMA Operater requested SHUTDOWN!\n");
		    }
                    close(newSocket);
                    keepRunning = 0;
                    break;
                }

	        if (CobolStatus = cpirma()) {	/* Call COBOL to initialize */
                    if (auditON)  {
			fprintf(auditFile,"%s\n",ctime(&currentDateTime));
			fprintf(auditFile,": 'cpirma' Fatal Error: %s - shutting down CPI\n",CobolStatus);
		    }
                    close(newSocket);
                    newSocket=NULL;
		    cobexit(CobolStatus);
   		}
	        requestLength= strlen(socketBuffer);
	        if (CobolStatus = validate(&requestLength, socketBuffer)) {
		    if (auditON)  {
			fprintf(auditFile,"%s\n",ctime(&currentDateTime));
			fprintf(auditFile,": 'validate' Fatal Error: %s - shutting down CPI\n",CobolStatus);
		    }
                    close(newSocket);
                    newSocket=NULL;
		    cobexit(CobolStatus);
		}

	        bufferCount = 0;
	        do	
	        {   bufferCount = 1;
	    	    if (CobolStatus =	cpi_rma(socketBuffer,
						patientRecsBuffer)) {
                        if (auditON)  {
			    fprintf(auditFile,"%s\n",ctime(&currentDateTime));
			    fprintf(auditFile,": 'cpi_rma' Fatal Error: %s - shutting down CPI\n",CobolStatus);
			}
                        close(newSocket);
                        newSocket=NULL;
	    		cobexit(CobolStatus);
		    }

                    if (debugON > 99 )  {
			fprintf(debugFile,"RETURNED BUFFER=\n%s~\n", patientRecsBuffer);
		    }
                    /* if ( send(newSocket, &patientRecsBuffer,MAX_PATIENT_RECORD_SIZE,0 )<0 ){*/

		    if ( send(newSocket, &patientRecsBuffer, 3430, 0 )<0 ) {
                        if (auditON)  {
			    fprintf(auditFile,"%s\n",ctime(&currentDateTime));
			    fprintf(auditFile,": 'send' Fatal Error\n");
			}
                        close(newSocket);
                        newSocket=NULL;
			perror("send");
			exit(1);
		    }
	        } while (bufferCount == 0);
	    } /* if socket buffer len > 0 */
	} /* for (;;;) */
  } while (keepRunning == 1);

close(newSocket);
newSocket=NULL;
if (debugON)  {
    fprintf(debugFile,"%s\n",ctime(&currentDateTime));
    fprintf(debugFile,": Shutting Down CPI Program\n");
}
if (auditON) fclose(auditFile);
if (debugON) fclose(debugFile);
exit(0);
}
